# buffer overflow 0
**FLAG** - picoCTF{ov3rfl0ws_ar3nt_that_bad_c5ca6248}
## Approach
To start off I downloaded the vuln.c file from  picoctf, and went through the program till I noticed this section of the code
![image](https://github.com/user-attachments/assets/f79aeebb-49ba-4147-9e3a-48ee83f5ed6f)

the `gets()` function is infamous for being a massive vulnerability due to its potential for allowing overflows, this coupled with the fact that the `vuln` function used
the strcpy function(also known for causing potential vulnerability entry points)


![image](https://github.com/user-attachments/assets/c65f2724-dbd9-425a-a900-a515f4c0d48c)


knowing these facts, and also that the challenge was named buffer overflow, I assumed that entering a string longer than 100 characters would overflow , so I just entered an
arbitarily long string

```bash
root@DESKTOP-MPJ395R:/mnt/c/Users/Aditya/Downloads# nc saturn.picoctf.net 49747
Input: zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
picoCTF{ov3rfl0ws_ar3nt_that_bad_c5ca6248}
```
## Concepts Learnt
- Buffer Overflow

# format string 0
**FLAG** - picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_74f6c0e7}
## Approach
After connecting to the instance, I am met with these options

```bash
Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation: Gr%114d_Cheese
```

I knew the challenge involved format specifiers in someway or another , so I chose `Gr%114d_Cheese` (no other options look like format specifiers), after entering this I was prompted with another message from the terminal

```bash
Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
Enter your recommendation: Cla%sic_Che%s%steak
ClaCla%sic_Che%s%steakic_Che(null)
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_74f6c0e7}
```
From these options I chose `Cla%sic_Che%s%steak` because again format specifiers, ultimately this gives me the key, I think this works because all the `%s`
specifiers allow us to print stuff from the programs memory

## Incorrect Tangents
- Tried messing around with the `format-string-0.c` file
## Concepts Learnt
- Format String Attacks

# Two-Sum
**FLAG**- picoCTF{Tw0_Sum_Integer_Bu773R_0v3rfl0w_bc0adfd1}
The Problem States to enter two positive integers whose sum is less than zero, and one of the hints alludes to integer overflow, afterwards I check the source code
it uses two signed ints to account for a and b
```c
static int addIntOvf(int result, int a, int b) {
    result = a + b;
    if(a > 0 && b > 0 && result < 0)
        return -1;
    if(a < 0 && b < 0 && result > 0)
        return -1;
    return 0;
}
```
knowing that I just enter 2147483647 as both a and b, because the max limit of a signed int is 2^31-1 and that is equal to 2147483647, now this prolly is true for 2147483647 + any number that is within the limits of an integer, but it gets the job done and retrives the flag.

## Incorrect Tangents
- The Objective was pretty straightforward, had no errors
## Concepts Learnt
- Integer Overflow

# Flag Leak
**FLAG** - picoCTF{L34k1ng_Fl4g_0ff_St4ck_999e2824}
## Approach
We are given a file vuln.c and we need to utilize that to exploit the location of the flag. first off I disassemble it with gdb to get the following output
```assembly
  0x000000000000130e <+0>:     endbr64
   0x0000000000001312 <+4>:     push   rbp
   0x0000000000001313 <+5>:     mov    rbp,rsp
   0x0000000000001316 <+8>:     sub    rsp,0xd0
   0x000000000000131d <+15>:    mov    rax,QWORD PTR fs:0x28
   0x0000000000001326 <+24>:    mov    QWORD PTR [rbp-0x8],rax
   0x000000000000132a <+28>:    xor    eax,eax
   0x000000000000132c <+30>:    lea    rax,[rbp-0xd0]
   0x0000000000001333 <+37>:    mov    esi,0x40
   0x0000000000001338 <+42>:    mov    rdi,rax
   0x000000000000133b <+45>:    call   0x1289 <readflag>
   0x0000000000001340 <+50>:    lea    rax,[rip+0xd21]        # 0x2068
   0x0000000000001347 <+57>:    mov    rdi,rax
   0x000000000000134a <+60>:    mov    eax,0x0
   0x000000000000134f <+65>:    call   0x1130 <printf@plt>
   0x0000000000001354 <+70>:    lea    rax,[rbp-0x90]
   0x000000000000135b <+77>:    mov    rsi,rax
   0x000000000000135e <+80>:    lea    rax,[rip+0xd32]        # 0x2097
   0x0000000000001365 <+87>:    mov    rdi,rax
   0x0000000000001368 <+90>:    mov    eax,0x0
   0x000000000000136d <+95>:    call   0x1180 <__isoc99_scanf@plt>
   0x0000000000001372 <+100>:   lea    rax,[rip+0xd24]        # 0x209d
   0x0000000000001379 <+107>:   mov    rdi,rax
   0x000000000000137c <+110>:   call   0x1100 <puts@plt>
   0x0000000000001381 <+115>:   lea    rax,[rbp-0x90]
   0x0000000000001388 <+122>:   mov    rdi,rax
   0x000000000000138b <+125>:   mov    eax,0x0
   0x0000000000001390 <+130>:   call   0x1130 <printf@plt>
```
